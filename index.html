<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Realistic 3D Prague</title>
    <style>
        :root {
            --bg-light: #f4f4f4;
            --sidebar-bg: #ffffff;
            --primary-accent: #007bff;
            --text-dark: #333333;
            --text-muted: #6c757d;
            --sky-color: #87CEEB; /* Light sky blue */
            --building-color: #f0e6d2; /* Light beige for buildings */
        }
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html, body { width: 100%; height: 100dvh; overflow: hidden; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; background-color: var(--bg-light); color: var(--text-dark); }
        #app-container { display: flex; width: 100%; height: 100%; }
        #sidebar { width: 300px; flex-shrink: 0; background-color: var(--sidebar-bg); display: flex; flex-direction: column; box-shadow: 2px 0 15px rgba(0,0,0,0.1); z-index: 10; border-right: 1px solid #dee2e6; }
        #sidebar-header { padding: 20px; border-bottom: 1px solid #dee2e6; }
        #sidebar-header h1 { color: var(--primary-accent); font-size: 1.5em; margin-bottom: 5px; }
        #sidebar-header p { color: var(--text-muted); font-size: 0.9em; }
        #locations-list { list-style: none; overflow-y: auto; flex-grow: 1; -webkit-overflow-scrolling: touch; }
        #locations-list li { padding: 15px 20px; cursor: pointer; border-bottom: 1px solid #dee2e6; transition: background-color 0.2s ease-in-out; }
        #locations-list li:hover, #locations-list li.active { background-color: var(--primary-accent); color: white; font-weight: bold; }
        #canvas-container { flex-grow: 1; position: relative; }
        #loader {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: var(--text-dark); font-size: 1.2em; z-index: 100; text-align: center;
            background-color: rgba(255, 255, 255, 0.8); padding: 20px; border-radius: 8px; width: 90%; max-width: 400px;
        }
        .spinner { border: 4px solid rgba(0, 0, 0, 0.1); border-radius: 50%; border-top: 4px solid var(--primary-accent); width: 40px; height: 40px; animation: spin 1s linear infinite; margin: 0 auto 10px; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        @media (max-width: 768px) {
            #app-container { flex-direction: column; }
            #sidebar { width: 100%; height: 40%; flex-shrink: 1; border-right: none; border-bottom: 1px solid #dee2e6; }
            #canvas-container { height: 60%; }
        }
    </style>
</head>
<body>
    <div id="app-container">
        <div id="sidebar">
            <div id="sidebar-header"><h1>Prague Sights</h1><p>Select a destination to explore</p></div>
            <ul id="locations-list"></ul>
        </div>
        <div id="canvas-container">
            <div id="loader"><div class="spinner"></div><div id="loader-text">Loading Core Libraries...</div></div>
        </div>
    </div>
    
    <script>
        // BOOTLOADER SCRIPT
        const loaderText = document.getElementById('loader-text');
        const spinner = document.querySelector('.spinner');
        const LIBRARIES = [
            'https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.js',
            'https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.umd.js',
            'https://raw.githack.com/mrdoob/three.js/r128/examples/js/controls/OrbitControls.js'
        ];
        function loadScript(url) {
            return fetch(url).then(r => r.text()).then(t => {
                const s = document.createElement('script');
                s.textContent = t;
                document.head.appendChild(s);
            });
        }
        async function bootstrap() {
            try {
                for (const url of LIBRARIES) {
                    loaderText.textContent = `Loading ${url.split('/').pop()}...`;
                    await loadScript(url);
                }
                loaderText.textContent = 'Libraries loaded. Starting App...';
                startApp();
            } catch (error) {
                loaderText.textContent = 'Fatal Error: Could not load libraries. ' + error.message;
                spinner.style.display = 'none';
            }
        }
        
        function startApp() {
            try {
                const destinations = [ { name: "Prague Castle", lat: 50.0901, lon: 14.4005 }, { name: "Charles Bridge", lat: 50.0865, lon: 14.4113 }, { name: "Old Town Square", lat: 50.0874, lon: 14.4208 }, { name: "St. Vitus Cathedral", lat: 50.0909, lon: 14.4007 }, { name: "Astronomical Clock", lat: 50.0870, lon: 14.4208 }, { name: "Vyšehrad", lat: 50.0645, lon: 14.4182 }, { name: "Jewish Quarter (Josefov)", lat: 50.0906, lon: 14.4187 }, { name: "National Museum", lat: 50.0792, lon: 14.4307 }, { name: "Dancing House", lat: 50.0754, lon: 14.4140 }, { name: "Lennon Wall", lat: 50.0862, lon: 14.4072 }, { name: "Petřín Tower", lat: 50.0834, lon: 14.3949 }, { name: "Wenceslas Square", lat: 50.0809, lon: 14.4282 }, { name: "Prague Zoo", lat: 50.1171, lon: 14.4042 }, { name: "Municipal House", lat: 50.0881, lon: 14.4282 }, { name: "National Theatre", lat: 50.0811, lon: 14.4137 }, { name: "Golden Lane", lat: 50.0917, lon: 14.4037 }, { name: "Malá Strana (Lesser Town)", lat: 50.0880, lon: 14.4039 }, { name: "St. Nicholas Church (Malá Strana)", lat: 50.0880, lon: 14.4032 }, { name: "Old Royal Palace", lat: 50.0906, lon: 14.4018 }, { name: "Powder Tower", lat: 50.0873, lon: 14.4277 }, { name: "Museum of Communism", lat: 50.0869, lon: 14.4272 }, { name: "Strahov Monastery", lat: 50.0865, lon: 14.3905 }, { name: "Kampa Island", lat: 50.0847, lon: 14.4092 }, { name: "Church of Our Lady before Týn", lat: 50.0877, lon: 14.4226 }, { name: "Franz Kafka Museum", lat: 50.0878, lon: 14.4103 }, { name: "Letná Park", lat: 50.0955, lon: 14.4157 }, { name: "Clementinum", lat: 50.0865, lon: 14.4158 }, { name: "Rudolfinum", lat: 50.0898, lon: 14.4157 }, { name: "The Vrtba Garden", lat: 50.0871, lon: 14.4032 }, { name: "Speculum Alchemiae", lat: 50.0910, lon: 14.4194 }, { name: "St. George's Basilica", lat: 50.0911, lon: 14.4026 }, { name: "Old Jewish Cemetery", lat: 50.0901, lon: 14.4177 }, { name: "Náplavka Farmers Market", lat: 50.0718, lon: 14.4168 }, { name: "Žižkov Television Tower", lat: 50.0809, lon: 14.4513 }, { name: "Divoká Šárka", lat: 50.1064, lon: 14.3313 }, { name: "Španělská synagoga", lat: 50.0903, lon: 14.4206 }, { name: "Museum Kampa", lat: 50.0837, lon: 14.4087 }, { name: "Troja Palace", lat: 50.1147, lon: 14.4102 }, { name: "Prague Metronome", lat: 50.0946, lon: 14.4156 }, { name: "Henry's Tower (Jindřišská věž)", lat: 50.0842, lon: 14.4299 }, { name: "National Technical Museum", lat: 50.0984, lon: 14.4274 }, { name: "Wallenstein Palace", lat: 50.0904, lon: 14.4079 }, { name: "Infant Jesus of Prague", lat: 50.0865, lon: 14.4034 }, { name: "Slav Epic", lat: 50.0772, lon: 14.4148 }, { name: "Estates Theatre", lat: 50.0858, lon: 14.4230 }, { name: "Loreta Praha", lat: 50.0891, lon: 14.3934 }, { name: "House of the Black Madonna", lat: 50.0867, lon: 14.4258 }, { name: "Bertramka", lat: 50.0734, lon: 14.3965 }, { name: "Cross Club", lat: 50.1054, lon: 14.4690 }, { name: "Prague Planetarium", lat: 50.1042, lon: 14.4300 }];
                
                const MAP_CENTER_CONFIG = { lat: 50.0874, lon: 14.4208 };
                const TILE_ZOOM = 16;
                const TILE_GRID_SIZE = 7; // Keep this odd for a center tile
                
                let scene, camera, renderer, controls, activeMarker;
                const canvasContainer = document.getElementById('canvas-container');
                const loader = document.getElementById('loader');
                const appLoaderText = document.getElementById('loader-text'); // Re-declared for startApp scope
                const textureLoader = new THREE.TextureLoader();
                const terrainTiles = {}; // Stores terrain ImageData per tile key "x,y"

                function init() {
                    scene = new THREE.Scene();
                    scene.background = new THREE.Color(getComputedStyle(document.documentElement).getPropertyValue('--sky-color'));
                    camera = new THREE.PerspectiveCamera(60, canvasContainer.clientWidth / canvasContainer.clientHeight, 1, 20000);
                    camera.position.set(0, 1000, 1000);
                    
                    renderer = new THREE.WebGLRenderer({ antialias: true });
                    renderer.setPixelRatio(window.devicePixelRatio);
                    renderer.setSize(canvasContainer.clientWidth, canvasContainer.clientHeight);
                    renderer.shadowMap.enabled = true;
                    canvasContainer.appendChild(renderer.domElement);

                    controls = new THREE.OrbitControls(camera, renderer.domElement);
                    controls.enableDamping = true;
                    controls.dampingFactor = 0.05;
                    controls.minDistance = 50; // Allow closer zoom
                    controls.maxDistance = 5000; // Increased max distance slightly
                    controls.maxPolarAngle = Math.PI / 2.05; // Slightly more than PI/2 to see horizon a bit
                    
                    const ambientLight = new THREE.AmbientLight(0xffffff, 1.0); // Adjusted intensity
                    scene.add(ambientLight);
                    const directionalLight = new THREE.DirectionalLight(0xffffff, 1.5); // Adjusted intensity
                    directionalLight.position.set(-500, 1200, 800);
                    directionalLight.castShadow = true;
                    directionalLight.shadow.mapSize.width = 2048;
                    directionalLight.shadow.mapSize.height = 2048;
                    directionalLight.shadow.camera.near = 100;
                    directionalLight.shadow.camera.far = 3000;
                    directionalLight.shadow.camera.left = -1500;
                    directionalLight.shadow.camera.right = 1500;
                    directionalLight.shadow.camera.top = 1500;
                    directionalLight.shadow.camera.bottom = -1500;
                    scene.add(directionalLight);
                    // const shadowHelper = new THREE.CameraHelper(directionalLight.shadow.camera); // For debugging shadows
                    // scene.add(shadowHelper);

                    populateLocationsList();
                    loadMapAndBuildings(); // This will show loader updates
                    window.addEventListener('resize', onWindowResize, false);
                    animate();
                }

                async function loadMapAndBuildings() { 
                    appLoaderText.textContent = 'Loading terrain & map tiles...';
                    await loadTerrainAndMapTiles(); 
                    appLoaderText.textContent = 'Loading buildings...';
                    await loadBuildings(); 
                    // Loader hidden in loadBuildings success path
                }

                async function loadTerrainAndMapTiles() {
                    const centerTileX = lon2tile(MAP_CENTER_CONFIG.lon, TILE_ZOOM);
                    const centerTileY = lat2tile(MAP_CENTER_CONFIG.lat, TILE_ZOOM);
                    const halfGrid = Math.floor(TILE_GRID_SIZE / 2);
                    const tilePromises = [];
                    for (let i = -halfGrid; i <= halfGrid; i++) {
                        for (let j = -halfGrid; j <= halfGrid; j++) {
                            const tileX = centerTileX + i;
                            const tileY = centerTileY + j;
                            tilePromises.push(createTile(tileX, tileY, TILE_ZOOM));
                        }
                    }
                    await Promise.all(tilePromises);
                }
                
                async function createTile(x, y, z) {
                    const worldSize = tileToWorldSize(z);
                    const planeGeom = new THREE.PlaneGeometry(worldSize, worldSize, 32, 32); // Reduced segments for performance
                    const mapUrl = `https://tile.openstreetmap.org/${z}/${x}/${y}.png`;
                    
                    let mapTexture;
                    try {
                        mapTexture = await textureLoader.loadAsync(mapUrl);
                        mapTexture.encoding = THREE.sRGBEncoding;
                    } catch (e) {
                        console.error(`Failed to load map texture for tile ${x},${y} from ${mapUrl}:`, e);
                        mapTexture = new THREE.Texture(); // Placeholder to avoid breaking material
                    }

                    const planeMat = new THREE.MeshStandardMaterial({ 
                        map: mapTexture, 
                        roughness: 0.9, // More matte for ground
                        metalness: 0.1
                    });

                    const plane = new THREE.Mesh(planeGeom, planeMat);
                    plane.rotation.x = -Math.PI / 2;
                    plane.receiveShadow = true; // Terrain should receive shadows
                    scene.add(plane);
                    
                    const tilePos = tileToWorld(x, y, z); // This uses the global centerTileX/Y
                    plane.position.x = tilePos.x;
                    plane.position.z = tilePos.z;
                    
                    const terrainUrl = `https://api.maptiler.com/tiles/terrain-rgb/${z}/${x}/${y}.png?key=wUpgt1kwi2BbRLIzM8hn`; // YOUR API KEY HERE

                    try {
                        const terrainData = await getTerrainData(terrainUrl); // ImageData
                        
                        if (!terrainData || terrainData.width === 0 || terrainData.height === 0) {
                            console.warn(`Tile ${x},${y}: Invalid terrain data (e.g. from failed load: ${terrainUrl}). Skipping height modification.`);
                            terrainTiles[`${x},${y}`] = null; // Mark as no data
                            return; 
                        }
                        terrainTiles[`${x},${y}`] = terrainData; // Store it for getHeightAtPoint

                        const positions = planeGeom.attributes.position;
                        for (let i = 0; i < positions.count; i++) {
                            const u = positions.getX(i) / worldSize + 0.5; // From -worldSize/2..worldSize/2 to 0..1
                            const v = 1.0 - (positions.getY(i) / worldSize + 0.5); // PlaneGeometry Y is up, map v is down
                            
                            let height = sampleTerrain(terrainData, u, v);
                            if (isNaN(height)) {
                                height = 0; // Default to 0 if NaN to prevent geometry corruption
                            }
                            positions.setZ(i, height); // Local Z becomes world Y after rotation
                        }
                        positions.needsUpdate = true;
                        planeGeom.computeVertexNormals();
                    } catch (error) {
                        console.error(`Failed to process terrain for tile ${x},${y} (${terrainUrl}):`, error);
                        terrainTiles[`${x},${y}`] = null; // Mark as no data on error
                        appLoaderText.textContent = `Error loading terrain for some tiles. Some areas may be flat.`;
                    }
                }

                async function loadBuildings() {
                    try {
                        // appLoaderText.textContent = 'Loading buildings...'; // Already set by caller
                        const response = await fetch('prague_buildings.geojson');
                        if (!response.ok) throw new Error(`HTTP ${response.status} fetching GeoJSON`);
                        const geojson = await response.json();
                        
                        appLoaderText.textContent = `Processing ${geojson.features.length} buildings... This may take a moment.`;
                        // Yield to browser for UI update
                        await new Promise(resolve => setTimeout(resolve, 50)); 
                        
                        processGeoJson(geojson);
                        loader.style.display = 'none'; // Hide loader on success
                    } catch (error) {
                        appLoaderText.textContent = `Error loading buildings: ${error.message}. Buildings may not appear.`;
                        console.error("Building load error:", error);
                        // Do not hide loader on critical error for buildings, or provide different feedback
                        // spinner.style.display = 'none'; // Keep spinner if buildings are crucial
                    }
                }
                
                function processGeoJson(geojson) { 
                    const baseMaterial = new THREE.MeshStandardMaterial({
                        color: getComputedStyle(document.documentElement).getPropertyValue('--building-color'),
                        metalness: 0.1,
                        roughness: 0.7
                    });
                    let featureCount = 0;
                    const totalFeatures = geojson.features.length;

                    function processBatch(startIndex) {
                        const batchSize = 100; // Process 100 features at a time
                        for (let i = startIndex; i < Math.min(startIndex + batchSize, totalFeatures); i++) {
                            const feature = geojson.features[i];
                            if (feature.geometry) {
                                addBuilding(feature, baseMaterial);
                            }
                            featureCount++;
                        }

                        if (featureCount % 500 === 0 || featureCount === totalFeatures) {
                             appLoaderText.textContent = `Processed ${featureCount} / ${totalFeatures} buildings...`;
                        }

                        if (startIndex + batchSize < totalFeatures) {
                            requestAnimationFrame(() => processBatch(startIndex + batchSize));
                        } else {
                            // Optionally, loader can be hidden here if not already
                            // loader.style.display = 'none'; 
                            console.log("Finished processing all buildings.");
                        }
                    }
                    requestAnimationFrame(() => processBatch(0)); // Start batch processing
                }
                
                function addBuilding(feature, baseMat) {
                    const geomType = feature.geometry.type;
                    const coords = feature.geometry.coordinates;
                    const properties = feature.properties;
                    
                    let height;
                    const defaultFallbackHeight = 8 + Math.random() * 12;

                    if (properties && properties.height) {
                        if (typeof properties.height === 'string') {
                            height = parseFloat(properties.height);
                        } else if (typeof properties.height === 'number') {
                            height = properties.height;
                        }
                    }

                    if (isNaN(height) || height <= 0) {
                        if (properties && properties['building:levels']) {
                            let levels;
                            if (typeof properties['building:levels'] === 'string') {
                                levels = parseFloat(properties['building:levels']);
                            } else if (typeof properties['building:levels'] === 'number') {
                                levels = properties['building:levels'];
                            }
                            if (!isNaN(levels) && levels > 0) {
                                height = levels * 3.2; // Adjusted avg height per level
                            }
                        }
                    }

                    if (isNaN(height) || height <= 0) {
                        height = defaultFallbackHeight;
                    }
                    if (height > 300) height = 300; // Cap extreme heights

                    const shapeFromCoords = (polygon) => {
                        const shape = new THREE.Shape();
                        try {
                            if (!polygon || polygon.length < 3 || !polygon[0] || !Array.isArray(polygon[0]) || polygon[0].length < 2) return null;
                            const firstPoint = lonLatToWorld(polygon[0][0], polygon[0][1]);
                            if (isNaN(firstPoint.x) || isNaN(firstPoint.z)) return null;
                            shape.moveTo(firstPoint.x, firstPoint.z);
                            for (let i = 1; i < polygon.length; i++) {
                                if (!polygon[i] || !Array.isArray(polygon[i]) || polygon[i].length < 2) continue;
                                const point = lonLatToWorld(polygon[i][0], polygon[i][1]);
                                if (isNaN(point.x) || isNaN(point.z)) return null;
                                shape.lineTo(point.x, point.z);
                            }
                            return shape;
                        } catch (e) { 
                            // console.warn("Error creating shape from coordinates:", polygon, e);
                            return null; 
                        }
                    };

                    const createMesh = (shape) => {
                        if (!shape) return;
                        
                        const extrudeSettings = { steps: 1, depth: height, bevelEnabled: false };
                        let geometry;
                        try {
                            geometry = new THREE.ExtrudeGeometry(shape, extrudeSettings);
                        } catch (e) {
                            // console.error("Error creating ExtrudeGeometry:", e, "height:", height, "shape points:", shape.getPoints().length);
                            return; 
                        }
                        
                        geometry.center(); 
                        
                        const building = new THREE.Mesh(geometry, baseMat.clone()); 

                        const shapePoints = shape.getPoints();
                        let centroidX = 0, centroidZ = 0;
                        if (shapePoints.length > 0) {
                            shapePoints.forEach(p => { centroidX += p.x; centroidZ += p.y; });
                            centroidX /= shapePoints.length;
                            centroidZ /= shapePoints.length;
                        } else { // Fallback if shape has no points (should not happen if shapeFromCoords is robust)
                             if (coords && coords[0] && coords[0][0] && Array.isArray(coords[0][0]) && coords[0][0].length >=2) {
                                const fallbackWorldPos = lonLatToWorld(coords[0][0][0], coords[0][0][1]);
                                centroidX = fallbackWorldPos.x;
                                centroidZ = fallbackWorldPos.z;
                                if(isNaN(centroidX) || isNaN(centroidZ)) return; // Still NaN, can't place
                             } else return; // Cannot position
                        }
                        
                        building.position.set(centroidX, 0, centroidZ);
                        
                        const groundHeight = getHeightAtPoint(building.position.x, building.position.z);
                        if (isNaN(groundHeight)) {
                            building.position.y = height / 2; 
                        } else {
                            building.position.y = groundHeight + (height / 2); 
                        }

                        building.castShadow = true;
                        building.receiveShadow = true;
                        scene.add(building);
                    };

                    if (geomType === 'Polygon') {
                        if (coords && coords[0]) createMesh(shapeFromCoords(coords[0]));
                    } else if (geomType === 'MultiPolygon') {
                        if (coords) coords.forEach(polygon => {
                            if (polygon && polygon[0]) createMesh(shapeFromCoords(polygon[0]));
                        });
                    }
                }
                
                // --- Coordinate and Tile Utility Functions ---
                function lon2tile(lon, zoom) { return Math.floor((lon + 180) / 360 * Math.pow(2, zoom)); }
                function lat2tile(lat, zoom) { return Math.floor((1 - Math.log(Math.tan(lat * Math.PI / 180) + 1 / Math.cos(lat * Math.PI / 180)) / Math.PI) / 2 * Math.pow(2, zoom));}
                
                const _centerTileX = lon2tile(MAP_CENTER_CONFIG.lon, TILE_ZOOM); // Store calculated center tile
                const _centerTileY = lat2tile(MAP_CENTER_CONFIG.lat, TILE_ZOOM);
                const _worldScaleForZoom = (2 * Math.PI * 6378137) / Math.pow(2, TILE_ZOOM); // Pre-calculate for current zoom

                function lonLatToWorld(lon, lat) {
                    const tileXRelative = ((lon + 180) / 360 * Math.pow(2, TILE_ZOOM)) - _centerTileX;
                    const tileYRelative = ((1 - Math.log(Math.tan(lat * Math.PI / 180) + 1 / Math.cos(lat * Math.PI / 180)) / Math.PI) / 2 * Math.pow(2, TILE_ZOOM)) - _centerTileY;
                    return { x: tileXRelative * _worldScaleForZoom, z: tileYRelative * _worldScaleForZoom };
                }

                function tileToWorld(x, y, z) { // z is tile zoom, not world Z
                    // Calculates world position relative to the scene's map center
                    // Assumes x, y are absolute tile numbers for the given zoom z
                    if (z !== TILE_ZOOM) { // If a different zoom tile is requested for position (not typical here)
                        const scale = (2 * Math.PI * 6378137) / Math.pow(2, z);
                        const currentZoomCenterTileX = lon2tile(MAP_CENTER_CONFIG.lon, z);
                        const currentZoomCenterTileY = lat2tile(MAP_CENTER_CONFIG.lat, z);
                        return { x: (x - currentZoomCenterTileX) * scale, z: (y - currentZoomCenterTileY) * scale };
                    }
                    return { x: (x - _centerTileX) * _worldScaleForZoom, z: (y - _centerTileY) * _worldScaleForZoom };
                }

                function tileToWorldSize(z) { // Size of one tile at zoom z
                     return (2 * Math.PI * 6378137) / Math.pow(2, z);
                }
                
                async function getTerrainData(url) {
                    const image = await textureLoader.loadAsync(url); // loadAsync should handle image loading promise
                    const canvas = document.createElement('canvas');
                    canvas.width = image.image.width; // image.image is the HTMLImageElement
                    canvas.height = image.image.height;
                    const context = canvas.getContext('2d');
                    if (!context) throw new Error("Could not get 2D context for terrain processing");
                    context.drawImage(image.image, 0, 0);
                    return context.getImageData(0, 0, canvas.width, canvas.height);
                }

                function decodeHeight(r, g, b) { return -10000 + ((r * 256 * 256 + g * 256 + b) * 0.1); }
                
                function sampleTerrain(data, u, v) { // u, v are 0..1
                    if (!data) return 0; // No terrain data for this tile
                    const x = Math.max(0, Math.min(Math.floor(u * (data.width -1)), data.width -1)); // Clamp x
                    const y = Math.max(0, Math.min(Math.floor(v * (data.height-1)), data.height-1)); // Clamp y
                    const i = (y * data.width + x) * 4;
                    if (i < 0 || i + 2 >= data.data.length) return 0; // Out of bounds check
                    return decodeHeight(data.data[i], data.data[i+1], data.data[i+2]);
                }

                function getHeightAtPoint(worldX, worldZ) {
                    // Convert world coordinates to the tile grid system
                    const tileX = Math.floor(worldX / _worldScaleForZoom + _centerTileX);
                    const tileY = Math.floor(worldZ / _worldScaleForZoom + _centerTileY);
                    
                    const data = terrainTiles[`${tileX},${tileY}`];
                    if (!data) return 0; // No terrain data for this specific tile, return flat

                    // Calculate u,v within that specific tile
                    // (worldX % _worldScaleForZoom) can be negative if worldX is negative
                    let u = (worldX - (tileX - _centerTileX) * _worldScaleForZoom) / _worldScaleForZoom;
                    let v = (worldZ - (tileY - _centerTileY) * _worldScaleForZoom) / _worldScaleForZoom;

                    // Ensure u,v are within [0,1) for sampling
                    u = u - Math.floor(u); 
                    v = v - Math.floor(v);

                    return sampleTerrain(data, u, v);
                }
                
                // --- UI and Camera Functions ---
                function populateLocationsList() { 
                    const list = document.getElementById('locations-list'); 
                    destinations.forEach((dest, index) => { 
                        const li = document.createElement('li'); 
                        li.textContent = dest.name; 
                        li.dataset.index = index; 
                        li.addEventListener('click', onLocationClick); 
                        list.appendChild(li); 
                    }); 
                }
                
                function onLocationClick(event) { 
                    document.querySelectorAll('#locations-list li').forEach(item => item.classList.remove('active')); 
                    event.target.classList.add('active'); 
                    const destination = destinations[event.target.dataset.index]; 
                    flyTo(destination); 
                }
                
                function flyTo(destination) {
                    const targetWorldPos = lonLatToWorld(destination.lon, destination.lat);
                    if (isNaN(targetWorldPos.x) || isNaN(targetWorldPos.z)) {
                        console.error("Cannot fly to destination, invalid coordinates:", destination);
                        return;
                    }

                    const targetHeight = getHeightAtPoint(targetWorldPos.x, targetWorldPos.z);
                    const cameraTargetY = isNaN(targetHeight) ? 200 : targetHeight + 200; // Viewing height above target
                    const cameraTargetZOffset = 300; // Distance behind target

                    const cameraTargetPos = { x: targetWorldPos.x, y: cameraTargetY, z: targetWorldPos.z + cameraTargetZOffset };
                    
                    if (!activeMarker) { 
                        const markerGeo = new THREE.CylinderGeometry(10, 0, 40, 8); // Smaller marker
                        const markerMat = new THREE.MeshStandardMaterial({ 
                            color: getComputedStyle(document.documentElement).getPropertyValue('--primary-accent'), 
                            emissive: getComputedStyle(document.documentElement).getPropertyValue('--primary-accent'), 
                            emissiveIntensity: 0.6 
                        }); 
                        activeMarker = new THREE.Mesh(markerGeo, markerMat);
                        scene.add(activeMarker); 
                    }
                    const markerY = isNaN(targetHeight) ? 20 : targetHeight + 20; // Marker height above ground
                    activeMarker.position.set(targetWorldPos.x, markerY, targetWorldPos.z);
                    activeMarker.visible = true; 
                    
                    new TWEEN.Tween(camera.position).to(cameraTargetPos, 2000).easing(TWEEN.Easing.Quadratic.InOut).start(); 
                    new TWEEN.Tween(controls.target).to({ x: targetWorldPos.x, y: isNaN(targetHeight) ? 0 : targetHeight, z: targetWorldPos.z }, 2000).easing(TWEEN.Easing.Quadratic.InOut).start(); 
                }
                
                function onWindowResize() { 
                    camera.aspect = canvasContainer.clientWidth / canvasContainer.clientHeight; 
                    camera.updateProjectionMatrix(); 
                    renderer.setSize(canvasContainer.clientWidth, canvasContainer.clientHeight); 
                }
                
                function animate() { 
                    requestAnimationFrame(animate); 
                    TWEEN.update(); 
                    controls.update(); 
                    renderer.render(scene, camera); 
                }
                
                init(); // Start the application
            } catch (e) {
                // This catch is for errors during startApp synchronous setup, not async operations within
                document.getElementById('loader-text').textContent = 'A critical application error occurred: ' + e.message;
                const spinnerEl = document.querySelector('#loader .spinner');
                if(spinnerEl) spinnerEl.style.display = 'none';
                console.error("Critical App Error:", e);
            }
        }
        bootstrap(); // Start the bootloader
    </script>
</body>
</html>
