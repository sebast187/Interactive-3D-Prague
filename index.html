<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Realistic 3D Prague</title>
    <style>
        :root {
            --bg-light: #f4f4f4;
            --sidebar-bg: #ffffff;
            --primary-accent: #007bff;
            --text-dark: #333333;
            --text-muted: #6c757d;
            --sky-color: #87CEEB; /* Light sky blue */
            --building-color: #f0e6d2; /* Light beige for buildings */
        }
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html, body { width: 100%; height: 100dvh; overflow: hidden; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; background-color: var(--bg-light); color: var(--text-dark); }
        #app-container { display: flex; width: 100%; height: 100%; }
        #sidebar { width: 300px; flex-shrink: 0; background-color: var(--sidebar-bg); display: flex; flex-direction: column; box-shadow: 2px 0 15px rgba(0,0,0,0.1); z-index: 10; border-right: 1px solid #dee2e6; }
        #sidebar-header { padding: 20px; border-bottom: 1px solid #dee2e6; }
        #sidebar-header h1 { color: var(--primary-accent); font-size: 1.5em; margin-bottom: 5px; }
        #sidebar-header p { color: var(--text-muted); font-size: 0.9em; }
        #locations-list { list-style: none; overflow-y: auto; flex-grow: 1; -webkit-overflow-scrolling: touch; }
        #locations-list li { padding: 15px 20px; cursor: pointer; border-bottom: 1px solid #dee2e6; transition: background-color 0.2s ease-in-out; }
        #locations-list li:hover, #locations-list li.active { background-color: var(--primary-accent); color: white; font-weight: bold; }
        #canvas-container { flex-grow: 1; position: relative; }
        #loader {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: var(--text-dark); font-size: 1.2em; z-index: 100; text-align: center;
            background-color: rgba(255, 255, 255, 0.8); padding: 20px; border-radius: 8px; width: 90%; max-width: 400px;
        }
        .spinner { border: 4px solid rgba(0, 0, 0, 0.1); border-radius: 50%; border-top: 4px solid var(--primary-accent); width: 40px; height: 40px; animation: spin 1s linear infinite; margin: 0 auto 10px; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        @media (max-width: 768px) {
            #app-container { flex-direction: column; }
            #sidebar { width: 100%; height: 40%; flex-shrink: 1; border-right: none; border-bottom: 1px solid #dee2e6; }
            #canvas-container { height: 60%; }
        }
    </style>
</head>
<body>
    <div id="app-container">
        <div id="sidebar">
            <div id="sidebar-header"><h1>Prague Sights</h1><p>Select a destination to explore</p></div>
            <ul id="locations-list"></ul>
        </div>
        <div id="canvas-container">
            <div id="loader"><div class="spinner"></div><div id="loader-text">Loading Core Libraries...</div></div>
        </div>
    </div>
    
    <script>
        // BOOTLOADER SCRIPT
        const loaderText = document.getElementById('loader-text');
        const spinner = document.querySelector('.spinner');
        const LIBRARIES = [
            'https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.js',
            'https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.umd.js',
            'https://raw.githack.com/mrdoob/three.js/r128/examples/js/controls/OrbitControls.js'
        ];
        function loadScript(url) {
            return fetch(url).then(r => r.text()).then(t => {
                const s = document.createElement('script');
                s.textContent = t;
                document.head.appendChild(s);
            });
        }
        async function bootstrap() {
            try {
                for (const url of LIBRARIES) {
                    loaderText.textContent = `Loading ${url.split('/').pop()}...`;
                    await loadScript(url);
                }
                loaderText.textContent = 'Libraries loaded. Starting App...';
                startApp();
            } catch (error) {
                loaderText.textContent = 'Fatal Error: Could not load libraries. ' + error.message;
                spinner.style.display = 'none';
            }
        }
        
        function startApp() {
            try {
                const destinations = [ { name: "Prague Castle", lat: 50.0901, lon: 14.4005 }, { name: "Charles Bridge", lat: 50.0865, lon: 14.4113 }, { name: "Old Town Square", lat: 50.0874, lon: 14.4208 }, { name: "St. Vitus Cathedral", lat: 50.0909, lon: 14.4007 }, { name: "Astronomical Clock", lat: 50.0870, lon: 14.4208 }, { name: "Vyšehrad", lat: 50.0645, lon: 14.4182 }, { name: "Jewish Quarter (Josefov)", lat: 50.0906, lon: 14.4187 }, { name: "National Museum", lat: 50.0792, lon: 14.4307 }, { name: "Dancing House", lat: 50.0754, lon: 14.4140 }, { name: "Lennon Wall", lat: 50.0862, lon: 14.4072 }, { name: "Petřín Tower", lat: 50.0834, lon: 14.3949 }, { name: "Wenceslas Square", lat: 50.0809, lon: 14.4282 }, { name: "Prague Zoo", lat: 50.1171, lon: 14.4042 }, { name: "Municipal House", lat: 50.0881, lon: 14.4282 }, { name: "National Theatre", lat: 50.0811, lon: 14.4137 }, { name: "Golden Lane", lat: 50.0917, lon: 14.4037 }, { name: "Malá Strana (Lesser Town)", lat: 50.0880, lon: 14.4039 }, { name: "St. Nicholas Church (Malá Strana)", lat: 50.0880, lon: 14.4032 }, { name: "Old Royal Palace", lat: 50.0906, lon: 14.4018 }, { name: "Powder Tower", lat: 50.0873, lon: 14.4277 }, { name: "Museum of Communism", lat: 50.0869, lon: 14.4272 }, { name: "Strahov Monastery", lat: 50.0865, lon: 14.3905 }, { name: "Kampa Island", lat: 50.0847, lon: 14.4092 }, { name: "Church of Our Lady before Týn", lat: 50.0877, lon: 14.4226 }, { name: "Franz Kafka Museum", lat: 50.0878, lon: 14.4103 }, { name: "Letná Park", lat: 50.0955, lon: 14.4157 }, { name: "Clementinum", lat: 50.0865, lon: 14.4158 }, { name: "Rudolfinum", lat: 50.0898, lon: 14.4157 }, { name: "The Vrtba Garden", lat: 50.0871, lon: 14.4032 }, { name: "Speculum Alchemiae", lat: 50.0910, lon: 14.4194 }, { name: "St. George's Basilica", lat: 50.0911, lon: 14.4026 }, { name: "Old Jewish Cemetery", lat: 50.0901, lon: 14.4177 }, { name: "Náplavka Farmers Market", lat: 50.0718, lon: 14.4168 }, { name: "Žižkov Television Tower", lat: 50.0809, lon: 14.4513 }, { name: "Divoká Šárka", lat: 50.1064, lon: 14.3313 }, { name: "Španělská synagoga", lat: 50.0903, lon: 14.4206 }, { name: "Museum Kampa", lat: 50.0837, lon: 14.4087 }, { name: "Troja Palace", lat: 50.1147, lon: 14.4102 }, { name: "Prague Metronome", lat: 50.0946, lon: 14.4156 }, { name: "Henry's Tower (Jindřišská věž)", lat: 50.0842, lon: 14.4299 }, { name: "National Technical Museum", lat: 50.0984, lon: 14.4274 }, { name: "Wallenstein Palace", lat: 50.0904, lon: 14.4079 }, { name: "Infant Jesus of Prague", lat: 50.0865, lon: 14.4034 }, { name: "Slav Epic", lat: 50.0772, lon: 14.4148 }, { name: "Estates Theatre", lat: 50.0858, lon: 14.4230 }, { name: "Loreta Praha", lat: 50.0891, lon: 14.3934 }, { name: "House of the Black Madonna", lat: 50.0867, lon: 14.4258 }, { name: "Bertramka", lat: 50.0734, lon: 14.3965 }, { name: "Cross Club", lat: 50.1054, lon: 14.4690 }, { name: "Prague Planetarium", lat: 50.1042, lon: 14.4300 }];
                
                const MAP_CENTER_CONFIG = { lat: 50.0874, lon: 14.4208 };
                const TILE_ZOOM = 16;
                const TILE_GRID_SIZE = 7;
                
                let scene, camera, renderer, controls, activeMarker;
                const canvasContainer = document.getElementById('canvas-container');
                const loader = document.getElementById('loader');
                const appLoaderText = document.getElementById('loader-text');
                const textureLoader = new THREE.TextureLoader();
                const terrainTiles = {};

                function init() {
                    scene = new THREE.Scene();
                    scene.background = new THREE.Color(getComputedStyle(document.documentElement).getPropertyValue('--sky-color'));
                    camera = new THREE.PerspectiveCamera(60, canvasContainer.clientWidth / canvasContainer.clientHeight, 1, 20000);
                    camera.position.set(0, 1000, 1000);
                    
                    renderer = new THREE.WebGLRenderer({ antialias: true });
                    
                    renderer.setPixelRatio(window.devicePixelRatio);
                    renderer.setSize(canvasContainer.clientWidth, canvasContainer.clientHeight);
                    renderer.shadowMap.enabled = true;
                    canvasContainer.appendChild(renderer.domElement);
                    controls = new THREE.OrbitControls(camera, renderer.domElement);
                    controls.enableDamping = true;
                    controls.dampingFactor = 0.05;
                    controls.minDistance = 100;
                    controls.maxDistance = 4000;
                    controls.maxPolarAngle = Math.PI / 2.1;
                    const ambientLight = new THREE.AmbientLight(0xffffff, 1.0);
                    scene.add(ambientLight);
                    const directionalLight = new THREE.DirectionalLight(0xffffff, 1.5);
                    directionalLight.position.set(-500, 1200, 800);
                    directionalLight.castShadow = true;
                    directionalLight.shadow.mapSize.width = 2048;
                    directionalLight.shadow.mapSize.height = 2048;
                    scene.add(directionalLight);
                    populateLocationsList();
                    loadMapAndBuildings();
                    window.addEventListener('resize', onWindowResize, false);
                    animate();
                }

                async function loadMapAndBuildings() { await loadTerrainAndMapTiles(); await loadBuildings(); }
                async function loadTerrainAndMapTiles() {
                    appLoaderText.textContent = 'Loading terrain & map...';
                    const centerTileX = lon2tile(MAP_CENTER_CONFIG.lon, TILE_ZOOM);
                    const centerTileY = lat2tile(MAP_CENTER_CONFIG.lat, TILE_ZOOM);
                    const halfGrid = Math.floor(TILE_GRID_SIZE / 2);
                    const tilePromises = [];
                    for (let i = -halfGrid; i <= halfGrid; i++) {
                        for (let j = -halfGrid; j <= halfGrid; j++) {
                            const tileX = centerTileX + i;
                            const tileY = centerTileY + j;
                            tilePromises.push(createTile(tileX, tileY, TILE_ZOOM));
                        }
                    }
                    await Promise.all(tilePromises);
                }
                
                async function createTile(x, y, z) {
                    const worldSize = tileToWorldSize(z);
                    const planeGeom = new THREE.PlaneGeometry(worldSize, worldSize, 64, 64);
                    const mapUrl = `https://tile.openstreetmap.org/${z}/${x}/${y}.png`;
                    const mapTexture = await textureLoader.loadAsync(mapUrl);
                    mapTexture.encoding = THREE.sRGBEncoding;

                    // --- FIX: APPLY POLYGON OFFSET TO THE MAP TILE MATERIAL TO PREVENT Z-FIGHTING ---
                    const planeMat = new THREE.MeshStandardMaterial({ 
                        map: mapTexture, 
                        roughness: 0.8, 
                        metalness: 0.2,
                        polygonOffset: true,
                        polygonOffsetFactor: -1.0, // A negative factor pushes it away from the camera
                        polygonOffsetUnits: -1.0
                    });

                    const plane = new THREE.Mesh(planeGeom, planeMat);
                    plane.rotation.x = -Math.PI / 2;
                    scene.add(plane);
                    const tilePos = tileToWorld(x, y, z);
                    plane.position.x = tilePos.x;
                    plane.position.z = tilePos.z;
                    const terrainUrl = `https://api.maptiler.com/tiles/terrain-rgb/${z}/${x}/${y}.png?key=get_your_own_D6C245K8p32A3sJa2f58`;
                    const terrainData = await getTerrainData(terrainUrl);
                    terrainTiles[`${x},${y}`] = terrainData;
                    const positions = planeGeom.attributes.position;
                    for (let i = 0; i < positions.count; i++) {
                        const u = positions.getX(i) / worldSize + 0.5;
                        const v = 1.0 - (positions.getY(i) / worldSize + 0.5);
                        const height = sampleTerrain(terrainData, u, v);
                        positions.setZ(i, height);
                    }
                    positions.needsUpdate = true;
                    planeGeom.computeVertexNormals();
                }

                async function loadBuildings() {
                    try {
                        appLoaderText.textContent = 'Loading buildings...';
                        // Note: You must provide the prague_buildings.geojson file for this to work.
                        // For testing, this fetch might fail if the file is not in the same directory.
                        const response = await fetch('prague_buildings.geojson');
                        if (!response.ok) throw new Error(`HTTP ${response.status} fetching GeoJSON`);
                        const geojson = await response.json();
                        appLoaderText.textContent = `Processing ${geojson.features.length} buildings...`;
                        await new Promise(resolve => setTimeout(resolve, 50));
                        processGeoJson(geojson);
                        loader.style.display = 'none';
                    } catch (error) {
                        appLoaderText.textContent = `Error: ${error.message}. Buildings could not be loaded. Please ensure 'prague_buildings.geojson' is present.`;
                        spinner.style.display = 'none';
                        // Keep the app running without buildings
                        setTimeout(() => { loader.style.display = 'none'; }, 4000);
                    }
                }
                
                function processGeoJson(geojson) { 
                    const baseMaterial = new THREE.MeshStandardMaterial({
                        color: getComputedStyle(document.documentElement).getPropertyValue('--building-color'),
                        metalness: 0.1,
                        roughness: 0.6
                    });
                    geojson.features.forEach(feature => { 
                        if (feature.geometry) addBuilding(feature, baseMaterial); 
                    });
                }
                
                function addBuilding(feature, baseMat) {
                    const geomType = feature.geometry.type;
                    const coords = feature.geometry.coordinates;
                    const properties = feature.properties;
                    let height = properties.height || (properties['building:levels'] ? properties['building:levels'] * 3.5 : 10 + Math.random() * 20);
                    const shapeFromCoords = (polygon) => {
                        const shape = new THREE.Shape();
                        try {
                            const firstPoint = lonLatToWorld(polygon[0][0], polygon[0][1]);
                            shape.moveTo(firstPoint.x, firstPoint.z);
                            for (let i = 1; i < polygon.length; i++) {
                                const point = lonLatToWorld(polygon[i][0], polygon[i][1]);
                                shape.lineTo(point.x, point.z);
                            }
                            return shape;
                        } catch (e) { return null; }
                    };
                    const createMesh = (shape) => {
                        if (!shape) return;
                        const extrudeSettings = { steps: 1, depth: height, bevelEnabled: false };
                        const geometry = new THREE.ExtrudeGeometry(shape, extrudeSettings);
                        geometry.center();
                        const building = new THREE.Mesh(geometry, baseMat);
                        const centroid = shape.getPoints().reduce((acc, p) => acc.add(p), new THREE.Vector2()).divideScalar(shape.getPoints().length);
                        building.position.set(centroid.x, 0, centroid.y);
                        
                        const groundHeight = getHeightAtPoint(building.position.x, building.position.z);
                        building.position.y = groundHeight + (height / 2); 

                        building.castShadow = true;
                        building.receiveShadow = true;
                        scene.add(building);
                    };
                    if (geomType === 'Polygon') {
                        createMesh(shapeFromCoords(coords[0]));
                    } else if (geomType === 'MultiPolygon') {
                        coords.forEach(polygon => createMesh(shapeFromCoords(polygon[0])));
                    }
                }
                
                function lon2tile(lon, zoom) { return Math.floor((lon + 180) / 360 * Math.pow(2, zoom)); }
                function lat2tile(lat, zoom) { return Math.floor((1 - Math.log(Math.tan(lat * Math.PI / 180) + 1 / Math.cos(lat * Math.PI / 180)) / Math.PI) / 2 * Math.pow(2, zoom));}
                const centerTileX = lon2tile(MAP_CENTER_CONFIG.lon, TILE_ZOOM);
                const centerTileY = lat2tile(MAP_CENTER_CONFIG.lat, TILE_ZOOM);
                function lonLatToWorld(lon, lat) {
                    const tileX = (lon + 180) / 360 * Math.pow(2, TILE_ZOOM);
                    const tileY = (1 - Math.log(Math.tan(lat * Math.PI / 180) + 1 / Math.cos(lat * Math.PI / 180)) / Math.PI) / 2 * Math.pow(2, TILE_ZOOM);
                    const worldSize = tileToWorldSize(TILE_ZOOM);
                    return { x: (tileX - centerTileX) * worldSize, z: (tileY - centerTileY) * worldSize };
                }
                function tileToWorld(x, y, z) { const worldSize = tileToWorldSize(z); return { x: (x - centerTileX) * worldSize, z: (y - centerTileY) * worldSize }; }
                function tileToWorldSize(z) { return (2 * Math.PI * 6378137) / Math.pow(2, z); }
                async function getTerrainData(url) {
                    const image = await textureLoader.loadAsync(url);
                    const canvas = document.createElement('canvas');
                    canvas.width = image.image.width;
                    canvas.height = image.image.height;
                    const context = canvas.getContext('2d');
                    context.drawImage(image.image, 0, 0);
                    return context.getImageData(0, 0, canvas.width, canvas.height);
                }
                function decodeHeight(r, g, b) { return -10000 + ((r * 256 * 256 + g * 256 + b) * 0.1); }
                function sampleTerrain(data, u, v) {
                    const x = Math.floor(u * (data.width - 1));
                    const y = Math.floor(v * (data.height - 1));
                    const i = (y * data.width + x) * 4;
                    return decodeHeight(data.data[i], data.data[i+1], data.data[i+2]);
                }
                function getHeightAtPoint(worldX, worldZ) {
                    const worldSize = tileToWorldSize(TILE_ZOOM);
                    const tileX = Math.floor(worldX / worldSize) + centerTileX;
                    const tileY = Math.floor(worldZ / worldSize) + centerTileY;
                    const data = terrainTiles[`${tileX},${tileY}`];
                    if (!data) return 0;
                    const u = (worldX % worldSize) / worldSize;
                    const v = (worldZ % worldSize) / worldSize;
                    return sampleTerrain(data, u >= 0 ? u : u + 1, v >= 0 ? v : v + 1);
                }
                
                function populateLocationsList() { const list = document.getElementById('locations-list'); destinations.forEach((dest, index) => { const li = document.createElement('li'); li.textContent = dest.name; li.dataset.index = index; li.addEventListener('click', onLocationClick); list.appendChild(li); }); }
                function onLocationClick(event) { document.querySelectorAll('#locations-list li').forEach(item => item.classList.remove('active')); event.target.classList.add('active'); const destination = destinations[event.target.dataset.index]; flyTo(destination); }
                function flyTo(destination) {
                    const targetWorldPos = lonLatToWorld(destination.lon, destination.lat);
                    const targetHeight = getHeightAtPoint(targetWorldPos.x, targetWorldPos.z);
                    const cameraTargetPos = { x: targetWorldPos.x, y: targetHeight + 400, z: targetWorldPos.z + 600 };
                    if (!activeMarker) { 
                        const markerGeo = new THREE.CylinderGeometry(15, 0, 50, 8); 
                        const markerMat = new THREE.MeshStandardMaterial({ color: getComputedStyle(document.documentElement).getPropertyValue('--primary-accent'), emissive: getComputedStyle(document.documentElement).getPropertyValue('--primary-accent'), emissiveIntensity: 0.5 }); 
                        activeMarker = new THREE.Mesh(markerGeo, markerMat);
                        scene.add(activeMarker); 
                    }
                    activeMarker.position.set(targetWorldPos.x, targetHeight + 25, targetWorldPos.z);
                    activeMarker.visible = true; 
                    new TWEEN.Tween(camera.position).to(cameraTargetPos, 2000).easing(TWEEN.Easing.Cubic.InOut).start(); 
                    new TWEEN.Tween(controls.target).to({ x: targetWorldPos.x, y: targetHeight, z: targetWorldPos.z }, 2000).easing(TWEEN.Easing.Cubic.InOut).start(); 
                }
                function onWindowResize() { camera.aspect = canvasContainer.clientWidth / canvasContainer.clientHeight; camera.updateProjectionMatrix(); renderer.setSize(canvasContainer.clientWidth, canvasContainer.clientHeight); }
                function animate() { requestAnimationFrame(animate); TWEEN.update(); controls.update(); renderer.render(scene, camera); }
                
                init();
            } catch (e) {
                document.getElementById('loader-text').textContent = 'An application error occurred: ' + e.message;
                spinner.style.display = 'none';
            }
        }
        bootstrap();
    </script>
</body>
</html>
