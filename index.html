<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Interactive 3D Prague</title>
    <style>
        :root {
            --bg-dark: #121212;
            --sidebar-bg: #1e1e1e;
            --primary-accent: #e94560;
            --text-light: #f0f0f0;
            --text-muted: #a0a0a0;
            --ground-color: #2a2a2a;
            --building-color: #555555;
            --building-highlight: #e94560;
            --font-main: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            --error-color: #ff6b6b;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        html, body {
            width: 100%;
            height: 100dvh;
            overflow: hidden;
            font-family: var(--font-main);
            background-color: var(--bg-dark);
            color: var(--text-light);
        }

        #app-container { display: flex; width: 100%; height: 100%; }
        #sidebar { width: 300px; flex-shrink: 0; background-color: var(--sidebar-bg); display: flex; flex-direction: column; box-shadow: 2px 0 15px rgba(0,0,0,0.5); z-index: 10; }
        #sidebar-header { padding: 20px; border-bottom: 1px solid #333; }
        #sidebar-header h1 { color: var(--primary-accent); font-size: 1.5em; margin-bottom: 5px; }
        #sidebar-header p { color: var(--text-muted); font-size: 0.9em; }
        #locations-list { list-style: none; overflow-y: auto; flex-grow: 1; }
        #locations-list li { padding: 15px 20px; cursor: pointer; border-bottom: 1px solid #333; transition: background-color 0.2s ease-in-out, color 0.2s ease-in-out; color: var(--text-light); }
        #locations-list li:hover { background-color: var(--primary-accent); color: white; }
        #locations-list li.active { background-color: var(--primary-accent); color: white; font-weight: bold; }
        #canvas-container { flex-grow: 1; position: relative; }
        #loader {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: var(--text-light);
            font-size: 1.2em;
            z-index: 100;
            text-align: center;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 20px;
            border-radius: 8px;
            width: 90%;
            max-width: 500px;
        }
        .spinner { border: 4px solid rgba(255, 255, 255, 0.2); border-radius: 50%; border-top: 4px solid var(--primary-accent); width: 40px; height: 40px; animation: spin 1s linear infinite; margin: 0 auto 10px; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        
        /* Debug log styles */
        #debug-log { margin-top: 15px; font-family: monospace; font-size: 0.8em; text-align: left; max-height: 150px; overflow-y: auto; background: #000; padding: 10px; border-radius: 4px; }
        #debug-log p { margin-bottom: 5px; }
        #debug-log .error { color: var(--error-color); font-weight: bold; }

        @media (max-width: 768px) {
            #app-container { flex-direction: column; }
            #sidebar { width: 100%; height: 40%; flex-shrink: 1; }
            #canvas-container { height: 60%; }
        }
    </style>
</head>
<body>
    <div id="app-container">
        <div id="sidebar">
            <div id="sidebar-header">
                <h1>Prague Sights</h1>
                <p>Select a destination to explore</p>
            </div>
            <ul id="locations-list"></ul>
        </div>
        <div id="canvas-container">
            <div id="loader">
                <div class="spinner"></div>
                <div id="loader-text">Loading 3D Map...</div>
                <!-- This is our new on-screen console -->
                <div id="debug-log"></div>
            </div>
        </div>
    </div>
    
    <script type="module">
        import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js';
        import { MapControls } from 'https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/controls/MapControls.js';
        import { TWEEN } from 'https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/libs/tween.module.min.js';

        // --- DATA OMITTED FOR BREVITY (keep your destinations array here) ---
        const destinations = [ { name: "Prague Castle", lat: 50.0901, lon: 14.4005 }, /* ...and so on for all 50 ... */ { name: "Prague Planetarium", lat: 50.1042, lon: 14.4300 }, ];
        
        let scene, camera, renderer, controls;
        let activeMarker;
        const canvasContainer = document.getElementById('canvas-container');
        const loader = document.getElementById('loader');
        const loaderText = document.getElementById('loader-text');
        const debugLog = document.getElementById('debug-log');
        
        const MAP_CENTER = { lat: 50.0874, lon: 14.4208 };

        // ===================================================================
        // NEW DEBUGGING FUNCTION TO SHOW LOGS ON SCREEN
        // ===================================================================
        function logToScreen(message, isError = false) {
            console.log(message); // Keep for desktop
            const p = document.createElement('p');
            p.textContent = message;
            if (isError) {
                p.classList.add('error');
            }
            debugLog.appendChild(p);
            debugLog.scrollTop = debugLog.scrollHeight; // Auto-scroll to bottom
        }

        // ===================================================================
        // HEAVILY MODIFIED FUNCTION TO DIAGNOSE THE PROBLEM
        // ===================================================================
        async function loadMapData() {
            logToScreen('1. Starting map data load...');
            try {
                const geoJsonPath = 'prague_buildings.geojson';
                logToScreen(`2. Attempting to fetch: ${geoJsonPath}`);
                
                const response = await fetch(geoJsonPath);
                
                logToScreen(`3. Fetch completed. HTTP Status: ${response.status} ${response.statusText}`);

                if (!response.ok) {
                    // This is for errors like 404 (Not Found) or 500 (Server Error)
                    const errorBody = await response.text();
                    logToScreen(`4. ERROR: Response was not OK.`, true);
                    logToScreen(`Server response (first 200 chars): ${errorBody.substring(0, 200)}`, true);
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                logToScreen('4. Response is OK. Trying to parse file as JSON...');
                const data = await response.json();
                
                logToScreen('5. JSON parsed successfully. Processing features...');
                if (!data.features || data.features.length === 0) {
                   logToScreen('6. WARNING: GeoJSON file seems to have no "features". It might be empty or corrupt.', true);
                } else {
                   logToScreen(`6. Found ${data.features.length} features. Building 3D models.`);
                }
                
                processGeoJson(data);

            } catch (error) {
                // This will catch network errors OR errors we throw ourselves.
                // A common error here is "SyntaxError: Unexpected token < in JSON at position 0"
                // which means the file is HTML (like a 404 page) instead of JSON.
                logToScreen(`>>> FINAL ERROR: ${error.message}`, true);
                loaderText.textContent = "Failed to load map.";
                document.querySelector('.spinner').style.display = 'none'; // Hide spinner on final error
            }
        }

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(getComputedStyle(document.documentElement).getPropertyValue('--bg-dark'));
            camera = new THREE.PerspectiveCamera(60, canvasContainer.clientWidth / canvasContainer.clientHeight, 0.1, 5000);
            camera.position.set(0, 500, 500);
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(canvasContainer.clientWidth, canvasContainer.clientHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            canvasContainer.appendChild(renderer.domElement);
            controls = new MapControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.screenSpacePanning = false;
            controls.minDistance = 50;
            controls.maxDistance = 2000;
            controls.maxPolarAngle = Math.PI / 2.2;
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0);
            directionalLight.position.set(-300, 800, 500);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            directionalLight.shadow.camera.left = -1500;
            directionalLight.shadow.camera.right = 1500;
            directionalLight.shadow.camera.top = 1500;
            directionalLight.shadow.camera.bottom = -1500;
            scene.add(directionalLight);
            const groundGeo = new THREE.PlaneGeometry(5000, 5000);
            const groundMat = new THREE.MeshStandardMaterial({ color: getComputedStyle(document.documentElement).getPropertyValue('--ground-color') });
            const ground = new THREE.Mesh(groundGeo, groundMat);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);
            const markerGeo = new THREE.CylinderGeometry(8, 0, 30, 8);
            const markerMat = new THREE.MeshStandardMaterial({ color: getComputedStyle(document.documentElement).getPropertyValue('--primary-accent'), emissive: getComputedStyle(document.documentElement).getPropertyValue('--primary-accent'), emissiveIntensity: 0.5 });
            activeMarker = new THREE.Mesh(markerGeo, markerMat);
            activeMarker.position.y = 15;
            activeMarker.visible = false;
            scene.add(activeMarker);
            populateLocationsList();
            loadMapData(); // This is the critical function
            window.addEventListener('resize', onWindowResize, false);
            animate();
        }
        
        function processGeoJson(geojson) {
            // (Keep this function as it was)
            const buildingMaterial = new THREE.MeshStandardMaterial({ color: getComputedStyle(document.documentElement).getPropertyValue('--building-color'), metalness: 0.3, roughness: 0.6 });
            for (const feature of geojson.features) { if (!feature.geometry) continue; const geomType = feature.geometry.type; const coords = feature.geometry.coordinates; if (geomType === 'Polygon') { addBuilding(coords, feature.properties, buildingMaterial); } else if (geomType === 'MultiPolygon') { coords.forEach(polygonCoords => { addBuilding(polygonCoords, feature.properties, buildingMaterial); }); } }
            loader.style.display = 'none';
        }

        // --- All other functions (addBuilding, populateLocationsList, flyTo, etc.) remain the same. ---
        // --- For brevity, I've omitted them, but they are in your original file and should stay. ---
        
        function addBuilding(coords, properties, material) { let height = properties.height || (properties['building:levels'] ? properties['building:levels'] * 3.5 : 10 + Math.random() * 20); const shape = new THREE.Shape(); const firstPoint = mercatorProjection(coords[0][0][0], coords[0][0][1]); shape.moveTo(firstPoint.x, firstPoint.z); for (let i = 1; i < coords[0].length; i++) { const point = mercatorProjection(coords[0][i][0], coords[0][i][1]); shape.lineTo(point.x, point.z); } const extrudeSettings = { steps: 1, depth: height, bevelEnabled: false }; const geometry = new THREE.ExtrudeGeometry(shape, extrudeSettings); const building = new THREE.Mesh(geometry, material); building.position.y = 0; building.castShadow = true; building.receiveShadow = true; scene.add(building); }
        function populateLocationsList() { const list = document.getElementById('locations-list'); destinations.forEach((dest, index) => { const li = document.createElement('li'); li.textContent = dest.name; li.dataset.index = index; li.addEventListener('click', onLocationClick); list.appendChild(li); }); }
        function onLocationClick(event) { const listItems = document.querySelectorAll('#locations-list li'); listItems.forEach(item => item.classList.remove('active')); event.target.classList.add('active'); const index = event.target.dataset.index; const destination = destinations[index]; flyTo(destination); }
        function flyTo(destination) { const targetPos = mercatorProjection(destination.lon, destination.lat); const cameraTargetPos = { x: targetPos.x, y: 200, z: targetPos.z + 300 }; activeMarker.position.x = targetPos.x; activeMarker.position.z = targetPos.z; activeMarker.visible = true; new TWEEN.Tween(camera.position).to(cameraTargetPos, 2000).easing(TWEEN.Easing.Cubic.InOut).start(); new TWEEN.Tween(controls.target).to({ x: targetPos.x, y: 0, z: targetPos.z }, 2000).easing(TWEEN.Easing.Cubic.InOut).start(); }
        function mercatorProjection(lon, lat) { const R = 6378137; const scale = 0.5; const x = R * (lon * Math.PI / 180 - MAP_CENTER.lon * Math.PI / 180) * scale; const y = R * Math.log(Math.tan(Math.PI / 4 + (lat * Math.PI / 180) / 2)) * scale; const center_y = R * Math.log(Math.tan(Math.PI / 4 + (MAP_CENTER.lat * Math.PI / 180) / 2)) * scale; return { x: x, z: -(y - center_y) }; }
        function onWindowResize() { camera.aspect = canvasContainer.clientWidth / canvasContainer.clientHeight; camera.updateProjectionMatrix(); renderer.setSize(canvasContainer.clientWidth, canvasContainer.clientHeight); }
        function animate() { requestAnimationFrame(animate); TWEEN.update(); controls.update(); renderer.render(scene, camera); }
        
        init();
    </script>
</body>
</html>
